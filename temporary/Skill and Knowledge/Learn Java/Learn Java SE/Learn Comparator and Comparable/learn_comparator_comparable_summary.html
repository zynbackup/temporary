<html>
<head>
<meta charset="UTF-8">
<style>
div.exampleOuter {
    outline: 1px double gray;
}

div.exampleHeader {
    font-weight: bold;
}

div.exampleInner {
    background-color: #d5dee3;
	display: inline-block;
	padding: 1px;
}

div.tab {
	margin: 1cm
}
</style>
</head>

<body>
source: <br/>
https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html <br/>
https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html <br/>
https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html <br/><br/>
<h2>Learn <code>java.util.Comparator</code> and <code>java.lang.Comparable</code> Summary</h2>

* <code>Comparator</code> or <code>Comparable</code> interface is needed to compare one object to another object. It is used primarily for sorting the object.
<br/><br/><br/>

<div class="exampleOuter">
<div class="exampleHeader">Example (ComparatorImplStringAscending.java)</div>
<div class="exampleInner">
<pre>
Example (ComparatorImplStringAscending.java)

package com.reinard.interfaces.impl;

import java.util.Comparator;

public class ComparatorImplStringAscending implements Comparator&lt;String&gt;{
	
	public ComparatorImplStringAscending(){
		super();
	}
	
	/**
	 * Compare String 1 and String 2. 
	 * 
	 * @return Positive integer (if String 1 greater than String 2, means that String 1 position comes after String 2 position). <br/> 
	 * Zero (if String 1 equals String 2, means that String 1 positions could comes after or comes before String 2 position). <br/>
	 * Negative integer (if String 1 less than String 2, means that String 1 positions comes before String 2 position).
	 */
	@Override
	public int compare(String s1, String s2) {
		int one = 0;
		int two = 0;
		
		switch(s1){
			case "a": one = 10;break; case "b": one = 20;break; case "c": one = 30;break;
			case "d": one = 40;break; case "e": one = 50;break; case "f": one = 60;break;
			case "g": one = 70;break; case "h": one = 80;break; case "i": one = 90;break;
			case "j": one = 100;break; case "k": one = 110;break; case "l": one = 120;break;
			case "m": one = 130;break; case "n": one = 140;break; case "o": one = 150;break;
			case "p": one = 160;break; case "q": one = 170;break; case "r": one = 180;break;
			case "s": one = 190;break; case "t": one = 200;break; case "u": one = 210;break;
			case "v": one = 220;break; case "w": one = 230;break; case "x": one = 240;break;
			case "y": one = 250;break; case "z": one = 260;break; 
			
		}
		
		switch(s2){
		case "a": two = 10;break; case "b": two = 20;break; case "c": two = 30;break;
		case "d": two = 40;break; case "e": two = 50;break; case "f": two = 60;break;
		case "g": two = 70;break; case "h": two = 80;break; case "i": two = 90;break;
		case "j": two = 100;break; case "k": two = 110;break; case "l": two = 120;break;
		case "m": two = 130;break; case "n": two = 140;break; case "o": two = 150;break;
		case "p": two = 160;break; case "q": two = 170;break; case "r": two = 180;break;
		case "s": two = 190;break; case "t": two = 200;break; case "u": two = 210;break;
		case "v": two = 220;break; case "w": two = 230;break; case "x": two = 240;break;
		case "y": two = 250;break; case "z": two = 260;break; 
		
		}
		
		return one - two;
	}
	
	
	public static void main(String[] args){
		ArrayList&lt;String&gt; codility = new ArrayList&lt;String&gt;();
		codility.add("c");
		codility.add("o");
		codility.add("d");
		codility.add("i");
		codility.add("l");
		codility.add("i");
		codility.add("t");
		codility.add("y");
		
		//sort the "codility" using the rule defined in "ComparatorImplStringAscending":
		Collections.sort(codility, new ComparatorImplStringAscending());
		
		for(String curr : codility){
			System.out.println(curr);
		}
		
	}

}</pre>

This code will print: <br/>
<pre>
c
d
i
i
l
o
t
y
</pre>

</div></div>
<br/><br/><br/>

<div class="exampleOuter">
<div class="exampleHeader">Example (ComparatorImplStringDescending.java)</div>
<div class="exampleInner">
<pre>
package com.reinard.interfaces.impl;

import java.util.Comparator;

public class ComparatorImplStringDescending implements Comparator&lt;String&gt {
	
	public ComparatorImplStringDescending(){
		super();
	}
	
	/**
	 * Compare String 1 and String 2. 
	 * 
	 * @return Positive integer (if String 1 greater than String 2, means that String 1 position comes after String 2 position). <br/> 
	 * Zero (if String 1 equals String 2, means that String 1 positions could comes after or comes before String 2 position). <br/>
	 * Negative integer (if String 1 less than String 2, means that String 1 positions comes before String 2 position).
	 */
	@Override
	public int compare(String s1, String s2) {
		int one = 0;
		int two = 0;
		
		switch(s1){
			case "a": one = 26;break; case "b": one = 25;break; case "c": one = 24;break;
			case "d": one = 23;break; case "e": one = 22;break; case "f": one = 21;break;
			case "g": one = 20;break; case "h": one = 19;break; case "i": one = 18;break;
			case "j": one = 17;break; case "k": one = 16;break; case "l": one = 15;break;
			case "m": one = 14;break; case "n": one = 13;break; case "o": one = 12;break;
			case "p": one = 11;break; case "q": one = 10;break; case "r": one = 9;break;
			case "s": one = 8;break; case "t": one = 7;break; case "u": one = 6;break;
			case "v": one = 5;break; case "w": one = 4;break; case "x": one = 3;break;
			case "y": one = 2;break; case "z": one = 1;break; 
			
		}
		
		switch(s2){
			case "a": two = 26;break; case "b": two = 25;break; case "c": two = 24;break;
			case "d": two = 23;break; case "e": two = 22;break; case "f": two = 21;break;
			case "g": two = 20;break; case "h": two = 19;break; case "i": two = 18;break;
			case "j": two = 17;break; case "k": two = 16;break; case "l": two = 15;break;
			case "m": two = 14;break; case "n": two = 13;break; case "o": two = 12;break;
			case "p": two = 11;break; case "q": two = 10;break; case "r": two = 9;break;
			case "s": two = 8;break; case "t": two = 7;break; case "u": two = 6;break;
			case "v": two = 5;break; case "w": two = 4;break; case "x": two = 3;break;
			case "y": two = 2;break; case "z": two = 1;break; 
		
		}
		
		return one - two;
	}
	
	
	public static void main(String[] args){
		ArrayList&lt;String&gt; codility = new ArrayList&lt;String&gt;();
		codility.add("c");
		codility.add("o");
		codility.add("d");
		codility.add("i");
		codility.add("l");
		codility.add("i");
		codility.add("t");
		codility.add("y");
		
		//sort the "codility" using the rule defined in "ComparatorImplStringDescending":
		Collections.sort(codility, new ComparatorImplStringDescending());
		
		for(String curr : codility){
			System.out.println(curr);
		}
		
	}
	
}

</pre>

This code will print:
<pre>
y
t
o
l
i
i
d
c
</pre>
</div></div>
<br/><br/><br/>



<div class="exampleOuter">
<div class="exampleHeader">Example (Employee.java)</div>
<div class="exampleInner">
<pre>
package com.reinard.model;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

public class Employee implements Comparable&lt;Employee&gt;{
	
	private int id; 
	private String name;
	
	public Employee(){
		super();
	}
	
	public Employee(int id, String name){
		super();
		this.id = id;
		this.name = name;
	}
	
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	/**
	 * Define the "natural ordering" rule for this object for comparing this Employee to another Employee object.
	 * 
	 * @return Positive integer (if this Employee.Id greater AnotherEmployee.Id, means that this Employee position comes after another Employee). <br/> 
	 * Zero (if this Employee.Id equals to AnotherEmployee.Id, means that this Employee position could comes after or comes before another Employee position). <br/>
	 * Negative integer (if this Employee.Id less than AnotherEmployee.Id, means that this Employee position comes before another Employee).
	 */
	@Override
	public int compareTo(Employee another) {
		
		//sort the Employee based on the Id, in ascending order:
		return id - another.getId();
	}
	
	
	public static void main(String[] args){
		//TreeSet&lt;Employee&gt; employees = new TreeSet();
		
		List&lt;Employee&gt; employees = new ArrayList();
		employees.add(new Employee(1, "Ironman"));
		employees.add(new Employee(8, "Batman"));
		employees.add(new Employee(7, "Superman"));
		employees.add(new Employee(3, "Hulk"));
		employees.add(new Employee(2, "Optimus Prime"));
		
		//Sort this List, according to the natural ordering of its elements.
		Collections.sort(employees);
		
		for(Employee curr : employees){
			System.out.println(curr.getName());
		}
		
		
	}
	
}
</pre>

This code will print:
<pre>
Ironman
Optimus Prime
Hulk
Superman
Batman
</pre>

</div></div>
<br/><br/><br/>



<div class="exampleOuter">
<div class="exampleHeader">Example (SortFileNameWithNumbers.java)</div>
<div class="exampleInner">
<pre>
package com.reinard.java;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

/**
 * This is a class to demonstrate the algorithm of file name with numbers sorting.
 * 
 * @author Reinard Hizkia Santosa
 * @updated 20 July 2016
 */
public class SortFileNameWithNumbers {
	
	/**
	 * This is a method to sort the file name with sequence numbers in it.
	 * The file name must contains a fixed length size. 
	 * Example of the fixed file name is: "LDE040E_01_00001_yyyymmdd.txt".
	 * Then, the sequence number is: 00001.
	 * 
	 * Example:
	 * Supposed there are 3 files with each file name is: 
	 * - LDE040E_01_00008_yyyymmdd.txt 
	 * - LDE040E_01_00012_yyyymmdd.txt 
	 * - LDE040E_01_00003_yyyymmdd.txt 
	 * 
	 * Then, this method should return an sorted array of String, with the position:
	 * ["LDE040E_01_00003_yyyymmdd.txt", "LDE040E_01_00008_yyyymmdd.txt", "LDE040E_01_00012_yyyymmdd.txt"].
	 * 
	 * The way I do it: 
	 * 1. Create an array of file name.
	 * 2. Implement the Comparator interface. 
	 * 3. Pass the implemented Comparator interface to "Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)" method. 
	 * 4. Sort the array with the Arrays.sort method that the implemented Comparator already passed. 
	 * 
	 * source: http://stackoverflow.com/questions/16898029/how-to-sort-file-names-in-ascending-order
	 */
	public static String[] sortFileNameWithNumbersAlgorithm(){
		
		String[] fileNamesArray = {"LDE040E_01_00768_yyyymmdd.txt", "LDE040E_01_00002_yyyymmdd.txt", "LDE040E_01_00007_yyyymmdd.txt"};
		
		//Sort the array, with this method.
		Arrays.sort(fileNamesArray, 
					//create new anonymous class that implements the Comparator interface.
					//The purpose of create this anonymous class that implement Comparator interface is to 
					//define own method to sort the array.
					new Comparator&lt;String&gt;(){
						
						//Override this compare method, to make own algorithm to sort the data.
						//This compare method is automatically used by java, to sort the array.
						@Override
						public int compare(String fileName1, String fileName2){
							
							try{
								int n1 = extractSequenceNumberFrom(fileName1);
								int n2 = extractSequenceNumberFrom(fileName2);
								return n1 - n2;
							}catch(Exception e){
								e.printStackTrace(System.out);
								return -99;
							}
						}
						
						public int extractSequenceNumberFrom(String fileName) throws Exception{
							//initial value
							int takeSequenceNumber = -99;
							try{
								//Take only the sequence number, from file name.
								//Example:
								//If the filename is: "LDE040E_01_00768_yyyymmdd.txt"
								//,then the sequence number is "00768".
								String takeSequenceNumberString = fileName.substring(11, 16);
								
								//Convert from String to int.
								takeSequenceNumber = Integer.parseInt(takeSequenceNumberString);
							}catch(IndexOutOfBoundsException e){
								throw new IndexOutOfBoundsException("Error when attempting to take sequence number from the file name");
							}catch(NumberFormatException e){
								throw new NumberFormatException("Sequence number in the file name cannot be parsed into integer!");
							}
							
							//if this variable still -99, then the extracted sequence number is not right.
							if(takeSequenceNumber == -99){
								throw new Exception("The extracted sequence number is not right !");
							}
							return takeSequenceNumber;
						}
					}
		);
		
		//Print the result of the sorted array.
		for(String current : fileNamesArray){
			System.out.println(current);
		}
		
		return fileNamesArray;
	}

}
</pre>

</body>
</html>